# Azure DevOps Pipeline Configuration
# ===================================

# Este archivo define el pipeline de CI/CD para Azure DevOps
# Se ejecuta automáticamente en cada push a la rama principal

trigger:
  - main # Se ejecuta cuando hay push a la rama main
  - develop # También se ejecuta en develop para testing

variables:
  # Variables globales del pipeline
  buildConfiguration: "Release"
  nodeVersion: "18.x"
  goVersion: "1.21"

stages:
  - stage: Build
    displayName: "Build Stage"
    jobs:
      - job: BuildJob
        displayName: "Build Application"
        pool:
          vmImage: "ubuntu-latest" # Usar Ubuntu para mejor compatibilidad

        steps:
          # Paso 1: Checkout del código
          - checkout: self
            displayName: "Checkout Code"

          # Paso 2: Configurar Node.js
          - task: NodeTool@0
            displayName: "Setup Node.js"
            inputs:
              versionSpec: $(nodeVersion)

          # Paso 3: Configurar Go
          - task: GoTool@0
            displayName: "Setup Go"
            inputs:
              version: $(goVersion)

          # Paso 4: Instalar dependencias del frontend
          - script: |
              echo "Instalando dependencias del frontend..."
              npm ci
            displayName: "Install Frontend Dependencies"

          # Paso 5: Instalar dependencias del backend
          - script: |
              echo "Instalando dependencias del backend..."
              cd EMARVE/backend
              go mod download
              go mod tidy
            displayName: "Install Backend Dependencies"

          # Paso 6: Ejecutar linters
          - script: |
              echo "Ejecutando linters..."
              make lint
            displayName: "Run Linters"

          # Paso 7: Ejecutar todos los tests
          - script: |
              echo "Ejecutando todos los tests..."
              make test
            displayName: "Run All Tests"
            continueOnError: false # Falla el pipeline si los tests fallan

          # Paso 8: Generar reporte de cobertura
          - script: |
              echo "Generando reporte de cobertura..."
              make test-coverage
            displayName: "Generate Coverage Report"

          # Paso 9: Publicar resultados de tests
          - task: PublishTestResults@2
            displayName: "Publish Test Results"
            inputs:
              testResultsFormat: "JUnit"
              testResultsFiles: "**/test-results.xml"
              mergeTestResults: true
              failTaskOnFailedTests: true

          # Paso 10: Publicar reporte de cobertura
          - task: PublishCodeCoverageResults@1
            displayName: "Publish Coverage Report"
            inputs:
              codeCoverageTool: "Cobertura"
              summaryFileLocation: "**/coverage.xml"
              reportDirectory: "**/coverage"

          # Paso 11: Build de la aplicación
          - script: |
              echo "Building application..."
              npm run build
            displayName: "Build Frontend"

          # Paso 12: Build del backend
          - script: |
              echo "Building backend..."
              cd EMARVE/backend
              go build -o main .
            displayName: "Build Backend"

          # Paso 13: Publicar artefactos
          - task: PublishBuildArtifacts@1
            displayName: "Publish Build Artifacts"
            inputs:
              pathToPublish: "$(System.DefaultWorkingDirectory)"
              artifactName: "drop"

  - stage: Deploy
    displayName: "Deploy Stage"
    dependsOn: Build
    condition: succeeded() # Solo se ejecuta si Build fue exitoso
    jobs:
      - deployment: DeployJob
        displayName: "Deploy to Production"
        pool:
          vmImage: "ubuntu-latest"
        environment: "production" # Ambiente de producción

        strategy:
          runOnce:
            deploy:
              steps:
                # Paso 1: Desplegar frontend
                - script: |
                    echo "Desplegando frontend..."
                    # Aquí irían los comandos específicos de despliegue
                    # Por ejemplo: docker-compose up -d
                  displayName: "Deploy Frontend"

                # Paso 2: Desplegar backend
                - script: |
                    echo "Desplegando backend..."
                    # Aquí irían los comandos específicos de despliegue
                  displayName: "Deploy Backend"

                # Paso 3: Verificar despliegue
                - script: |
                    echo "Verificando despliegue..."
                    # Health checks, smoke tests, etc.
                  displayName: "Verify Deployment"

  # Configuración adicional para notificaciones
  - stage: Notify
    displayName: "Notification Stage"
    dependsOn:
      - Build
      - Deploy
    condition: always() # Siempre se ejecuta
    jobs:
      - job: NotifyJob
        displayName: "Send Notifications"
        pool:
          vmImage: "ubuntu-latest"

        steps:
          - script: |
              echo "Enviando notificaciones..."
              # Aquí podrías integrar con Slack, Teams, email, etc.
            displayName: "Send Success/Failure Notifications"
